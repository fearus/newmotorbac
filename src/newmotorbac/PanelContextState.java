/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * PanelContextState.java
 *
 * Created on May 9, 2011, 11:13:38 AM
 */

package newmotorbac;

import newmotorbac.util.OrbacPolicyContext;
import java.awt.Color;
import java.awt.Component;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Vector;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextPane;
import javax.swing.JTree;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import orbac.context.CContext;
import orbac.exception.COrbacException;
import orbac.securityRules.CConcreteObligation;
import orbac.securityRules.CConcretePermission;
import orbac.securityRules.CConcreteProhibition;

/**
 *
 * @author fabien
 */
public class PanelContextState extends javax.swing.JPanel {
    // policy context
    private OrbacPolicyContext thisContext;
    // table renderer
    private ContextTableCellRenderer contextRenderer = new ContextTableCellRenderer();
    // tree root node
    private DefaultMutableTreeNode rootContext = new DefaultMutableTreeNode("All Contexts");
    // text zone
    private JTextPane contextInfos = new JTextPane();

    /** Creates new form PanelContextState */
    public PanelContextState(OrbacPolicyContext thisContext) {
        initComponents();

        // store policy context
        this.thisContext = thisContext;

        // setup context tree
        DefaultTreeModel model = (DefaultTreeModel)jTreeContexts.getModel();
        model.setRoot(rootContext);

        // setup table renderer
        // if the Object.class value is used as the first parameter, the renderer is not used...
        jTableContexts.setDefaultRenderer(String.class, contextRenderer);

        // display contexts in tree
        UpdateContextTree();
    }

    public void UpdateContextTree()
    {
        // get all contexts and create the tree structure, leafs are context definitions or contexts without definitions
        Map<String, CContext> contexts = thisContext.thePolicy.GetContexts();
        Collection<CContext> values = contexts.values();
        Iterator<CContext> ic = values.iterator();
        int defNumber = 0;
        while ( ic.hasNext() )
        {
            CContext c = ic.next();
            // add context to tree
            DefaultMutableTreeNode currentCtxNode = new DefaultMutableTreeNode( c.GetName() );
            rootContext.add( currentCtxNode );
            HashMap<String, String> defs = null;
            try
            {
                defs = c.GetContextDefinitions();
            }
            catch ( Exception e )
            {
                System.out.println(e);
                e.printStackTrace();
            }

            // if defs is null it means we retrieved a default context
            if ( defs == null )
            {
                // nothing to do for default context
            }
            else
            {
                Set< Entry<String, String> > keys = defs.entrySet();
                Iterator< Entry<String, String> > it = keys.iterator();
                while ( it.hasNext() )
                {
                    Entry<String, String> e = it.next();
                    String org = e.getKey();

                    // add org name for definition
                    currentCtxNode.add( new DefaultMutableTreeNode( org ) );

                    // add row
                    defNumber++;
                }
            }
        }
        expandAll(jTreeContexts, true);
        boolean[] contextRowsState = new boolean[ defNumber ];
        contextRenderer.SetRowStates(contextRowsState);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane = new javax.swing.JSplitPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTreeContexts = new javax.swing.JTree();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTableContexts = new javax.swing.JTable();

        setName("Form"); // NOI18N

        jSplitPane.setDividerLocation(200);
        jSplitPane.setName("jSplitPane"); // NOI18N

        jScrollPane1.setMinimumSize(new java.awt.Dimension(300, 25));
        jScrollPane1.setName("jScrollPane1"); // NOI18N
        jScrollPane1.setPreferredSize(new java.awt.Dimension(300, 402));

        jTreeContexts.setName("jTreeContexts"); // NOI18N
        jTreeContexts.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
            public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                jTreeContextsValueChanged(evt);
            }
        });
        jScrollPane1.setViewportView(jTreeContexts);

        jSplitPane.setLeftComponent(jScrollPane1);

        jScrollPane2.setName("jScrollPane2"); // NOI18N

        jTableContexts.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Subject", "Action", "Object"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jTableContexts.setName("jTableContexts"); // NOI18N
        jTableContexts.getTableHeader().setReorderingAllowed(false);
        jScrollPane2.setViewportView(jTableContexts);
        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(newmotorbac.NewMotorbacApp.class).getContext().getResourceMap(PanelContextState.class);
        jTableContexts.getColumnModel().getColumn(0).setHeaderValue(resourceMap.getString("jTableContexts.columnModel.title0")); // NOI18N
        jTableContexts.getColumnModel().getColumn(1).setHeaderValue(resourceMap.getString("jTableContexts.columnModel.title1")); // NOI18N
        jTableContexts.getColumnModel().getColumn(2).setHeaderValue(resourceMap.getString("jTableContexts.columnModel.title2")); // NOI18N

        jSplitPane.setRightComponent(jScrollPane2);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jSplitPane, javax.swing.GroupLayout.DEFAULT_SIZE, 423, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jSplitPane, javax.swing.GroupLayout.DEFAULT_SIZE, 224, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jTreeContextsValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_jTreeContextsValueChanged
        // get selected item
        DefaultMutableTreeNode node = (DefaultMutableTreeNode)jTreeContexts.getLastSelectedPathComponent();
        if ( node == null ) return;
        if ( node == rootContext )
        {
            jSplitPane.setBottomComponent(new JScrollPane(contextInfos,
                                          JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                                          JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED));
            contextInfos.setText("You can display a table filled with context states evaluated on contrete entities by selecting leafs in the context tree. A leaf represents "
                    + "an organization name in which a context definition has been specified");
        }
        // if a context name is selected, we display the definition list on the right
        else if ( node.getParent() == rootContext )
        {
            jSplitPane.setBottomComponent(new JScrollPane(contextInfos,
                                          JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                                          JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED));
            contextInfos.setText("Select an organization name to display the associated context definition " +
                                 "states for all related (subject, action, object) triples");
        }
        // if an organization name is selected we display the context state
        // for this definition for all related triples (subject, action, object)
        else
        {
            jSplitPane.setBottomComponent(jScrollPane2);
            String org = node.getUserObject().toString();
            // set definition
            DefaultMutableTreeNode contextNode = (DefaultMutableTreeNode)node.getParent();
            String contextName = contextNode.getUserObject().toString();
            CContext selectedContext = thisContext.thePolicy.GetContext(contextName);

            // fill table with context state
            DefaultTableModel contextModel = (DefaultTableModel)jTableContexts.getModel();
            try
            {
                contextModel.setNumRows(0);
                if ( selectedContext.DoesDefinitionDependsOnTriple(org) )
                {
                    Vector<Boolean> states = new Vector<Boolean>();
                    Set<CConcretePermission> permissions = thisContext.thePolicy.GetConcretePermissions();
                    Iterator<CConcretePermission> icperm = permissions.iterator();
                    while ( icperm.hasNext() )
                    {
                        CConcretePermission cp = icperm.next();
                        // check if rule's organization is a sub-organization
                        // of org
                        Set<String> suborgs = thisContext.thePolicy.GetSubOrganizations(org);
                        if ( cp.GetContext().equals(contextName) && suborgs.contains(org) )
                        {
                            String row[] = new String[3];
                            row[0] = cp.GetSubject();
                            row[1] = cp.GetAction();
                            row[2] = cp.GetObject();
                            contextModel.addRow(row);
                            if ( thisContext.thePolicy.IsPermited(cp) ) states.add(Boolean.TRUE);
                            else states.add(Boolean.FALSE);
                        }
                    }
                    Set<CConcreteProhibition> prohibitions = thisContext.thePolicy.GetConcreteProhibitions();
                    Iterator<CConcreteProhibition> icprohib = prohibitions.iterator();
                    while ( icprohib.hasNext() )
                    {
                        CConcreteProhibition cp = icprohib.next();
                        // check if rule's organization is a sub-organization
                        // of org
                        Set<String> suborgs = thisContext.thePolicy.GetSubOrganizations(org);
                        if ( cp.GetContext().equals(contextName) && suborgs.contains(org) )
                        {
                            String row[] = new String[3];
                            row[0] = cp.GetSubject();
                            row[1] = cp.GetAction();
                            row[2] = cp.GetObject();
                            contextModel.addRow(row);
                            if ( thisContext.thePolicy.IsProhibited(cp) ) states.add(Boolean.TRUE);
                            else states.add(Boolean.FALSE);
                        }
                    }
                    Set<CConcreteObligation> obligations = thisContext.thePolicy.GetConcreteObligations();
                    Iterator<CConcreteObligation> icoblig = obligations.iterator();
                    while ( icoblig.hasNext() )
                    {
                        CConcreteObligation cp = icoblig.next();
                        // check if rule's organization is a sub-organization
                        // of org
                        Set<String> suborgs = thisContext.thePolicy.GetSubOrganizations(org);
                        if ( cp.GetContext().equals(contextName) && suborgs.contains(org) )
                        {
                            String row[] = new String[3];
                            row[0] = cp.GetSubject();
                            row[1] = cp.GetAction();
                            row[2] = cp.GetObject();
                            contextModel.addRow(row);
                            if ( thisContext.thePolicy.IsObliged(cp) ) states.add(Boolean.TRUE);
                            else states.add(Boolean.FALSE);
                        }
                    }
                    boolean[] contextRowsState = new boolean[ states.size() ];
                    for (int i = 0; i < states.size(); i++)
                    {
                        if ( states.elementAt(i) == Boolean.TRUE ) contextRowsState[i] = true;
                        else contextRowsState[i] = false;
                    }
                    contextRenderer.SetRowStates(contextRowsState);
                }
                else
                {
                    String row[] = new String[3];
                    row[0] = "any subject";
                    row[1] = "any action";
                    row[2] = "any object";
                    contextModel.addRow(row);
                    boolean[] contextRowsState = new boolean[1];
                    contextRowsState[0] = selectedContext.GetState(org, "", "", "");
                    contextRenderer.SetRowStates(contextRowsState);
                }
                jTableContexts.invalidate();
            }
            catch ( COrbacException e )
            {
                System.out.println(e);
                e.printStackTrace();
            }
        }
    }//GEN-LAST:event_jTreeContextsValueChanged

    // method called to refresh the currently displayed context definition state
    public void UpdateDisplay()
    {
        jTreeContextsValueChanged(null);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSplitPane jSplitPane;
    private javax.swing.JTable jTableContexts;
    private javax.swing.JTree jTreeContexts;
    // End of variables declaration//GEN-END:variables

    public class ContextTableCellRenderer extends DefaultTableCellRenderer
    {
    	// just to remove the warning
    	static final long serialVersionUID = 0;

    	// to know how rows must be colored
    	private boolean rowsState[];

    	public void SetRowStates(boolean rowsState[])
    	{
            this.rowsState = rowsState;
    	}
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column)
        {
            Component cell = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
            if ( rowsState == null ) return cell;

            Color cellOn = new Color(0.7f, 1.0f, 0.7f);
            Color cellOff = new Color(1.0f, 0.7f, 0.7f);

            if ( rowsState[row] )
            {
                // set cell on
                cell.setBackground( cellOn );
                cell.setForeground( Color.BLACK );
            }
            else
            {
                // set cell light
                cell.setBackground( cellOff );
                cell.setForeground( Color.GRAY );
            }
            return cell;
        }
    }

    // If expand is true, expands all nodes in the tree
    // otherwise, collapses all nodes in the tree
    public void expandAll(JTree tree, boolean expand)
    {
        TreeNode root = (TreeNode)tree.getModel().getRoot();

        // Traverse tree from root
        expandAll(tree, new TreePath(root), expand);
    }
    private void expandAll(JTree tree, TreePath parent, boolean expand)
    {
        // Traverse children
        TreeNode node = (TreeNode)parent.getLastPathComponent();
        if (node.getChildCount() >= 0)
        {
            for (Enumeration<?> e=node.children(); e.hasMoreElements(); )
            {
                TreeNode n = (TreeNode)e.nextElement();
                TreePath path = parent.pathByAddingChild(n);
                expandAll(tree, path, expand);
            }
        }

        // Expansion or collapse must be done bottom-up
        if (expand) tree.expandPath(parent);
        else tree.collapsePath(parent);
    }
}
